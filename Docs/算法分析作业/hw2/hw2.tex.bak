\documentclass[a4paper]{article}
\usepackage{ctex}
\usepackage{fancyhdr}
\usepackage{mflogo,texnames}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{listings}
\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\definecolor{webgreen}{rgb}{0,.5,0}
\usepackage{geometry}
\geometry{left=3.18cm,right=3.18cm,
    top=2.54cm,bottom=2.54cm,
    head=1.5cm,foot=1.75cm}
\usepackage{multirow}
\pagestyle{fancy}
\lhead{学号：1401214342}
\chead{姓名: 韩}
\rhead{}
\lfoot{Han Zhe(icst@pku)}
\cfoot{iampkuhz@gmail.com}
\rfoot{\thepage}

% word page layout
%\usepackage[top=2.54cm, bottom=2.54cm, left=3.18cm, right=3.18cm]{geometry}
\title{My First \LaTeX{} article}
\begin{document}
\begin{center}
\LARGE 算法课第 2次作业
~\\
\end{center}

\begin{center}
 \begin{tabular}{|c|c|c|c|c|c|c|}
\hline
      & 题目1 & 题目2 & 题目3 & 题目4 & 题目5 & 总分\\ \hline
 \multirow{2}{*}{分数} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{}\\
 & & & & & & \\ \hline
 \multirow{2}{*}{阅卷人} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{} &\multirow{2}{*}{}\\
 & & & & & &  \\ \hline
\end{tabular}
\end{center}
%\section{题目1 洗钱模式}
%  \normalsize
%  \paragraph{算法}
%  每个洗钱转账都有一个可行区间$[t_i-e_i, t_i+e_i]$,我们把这n个洗钱区间的上界从小到大排序（假设排序后的顺序为$t_1,t_2,...,t_n$），将n个可疑事件从小到大排序（假设排序后的顺序为$x_1,x_2,...,x_n$）。则对n个洗钱区间，在$\{x_i\}$里面顺序查找在区间$[t_i-e_i, t_i+e_i]$的第一个候选事件作为$t_i$的对应事件，循环直到(1)n个$t_i$都找到配对或者(2)有一个$t_i$没有找到配对，说明不存在满足条件的配对。
%  \paragraph{复杂度分析}
%  可行区间排序复杂度$O(n\log n)$，可疑事件排序复杂度$O(n\log n)$；对于每个洗钱区间$[t_i-e_i, t_i+e_i]$，查找对应的可疑事件，复杂度是$O(n)$，所以总的匹配过程的复杂度是$O(n^2)$。总体复杂度为$O(n\log n + n\log n + n^2) = O(n^2)$
%  \paragraph{正确性证明}
%  下面证明，只要存在可行解，都等价于一个按照上述算法得到的配对。
%  假设有一个配对$P:\{(t_1, x_1), (t_2, x_2),..., (t_n, x_n)\}$, 设前$k-1$个配对和我们安装上述算法得到的匹配相同，第$k$个不同
%  $$\{(x_1, t_1), (x_2, t_2),..., (x_{k-1}, t_{k-1})\}$$
%  假设在我们的算法得到的配对里$t_k$和$x_j$配对。因为有$t_k$可以和$x_j$配对，所以$t_k$的配对是存在的，所以算法进行到第$k$步也能找到一个解。因为算法是顺序查找到$x_j$的，说明$x_j$ 是当时集合里最早的可以匹配$t_k$ 的点，所以$$x_j <= x_k (1)$$
%  在$P$中$x_j$和$t_j$结合，按照算法的步骤$t_j$在$t_k$之后，说明$$t_j+e_j>t_k+e_k (2)$$又因为$$t_j-e_j<=x_j (3)$$ $$t_k+e_k>=x_k (4)$$
%  由$(1)(2)(3)(4)$得 $$t_j-e_j<=x_j<=x_k<=t_k+e_k<=t_j+e_j$$所以我们将R中$(t_k, x_k), (t_j, x_j)$的匹配交换成$(t_k, x_j), (t_j, x_k)$依然是一个匹配，但是前$k$个都相同。递推可以将前$k+1, k+2,...,n$个都变为算法得到的满足要求的匹配。所以如果存在解，算法一定得到解。如果不存在解，显然算法得不到解。所以算法是正确的
%
%
%\section{题目2 最优生成树}
%  \paragraph{求最优生成树方法}
%  设有N个点。任取一点作为生成树的起始点$n_1$,一个已经在生成树的集合$A$，一个剩余点集$R$。初始时$R=\{n_1\}$,剩余点集$A=\{n_2,...,n_N\}$。接下来的每个循环中，从$A$中取一个点$n_k$加入$R$中，并在$n_k$与$R$中点的所有连线中选取一条加入$A$，形成一个大小为$k$的生成树。选线的方法为：初始化为第一条线，形成一棵大小为$k$的生成树，对于其他$n_k$与前一循环得到的$R$中点的连线，将其加入$R$，必然生成一个环，然后去掉环中权重最小的边。
%  \paragraph{证明正确性}
%  为了证明正确性，我们根据$u-v$的瓶颈链路的长度采用数学归纳法证明。\\
%  不妨假设在构造生成树的时候先加入$u$点，再加入$v$点。这里我们假设算法构造的生成树为$T_my$。\\
%  (1)当$u-v$的最优链路长度为1时，证明其在我们算法构造的路径上。反证，假设不在$T_my$上，则边$(u,v)$不在$T_my$上。再加入$v$点到$T_my$的时候$(u,v)$ 也在候选线段里，说明在加入时其生成了环且是换上权值最小的边。所以将$(u,v)$加入$T_my$后会形成环，这样就有两条$u-v$的不重叠的路径，显然非$(u,v)$边的那一条路径的每一段的阈值都大于等于边$(u,v)$，显然非$(u,v)$边的那一条路径是$u-v$的瓶颈路径，矛盾！所以最优瓶颈路径长度为1时成立\\
%  (2)设当$u-v$的最优链路长度小于等于k时成立，证明当$u-v$的最优链路长度为$k+1$时成立。反证。如果$u-v$的瓶颈路径实际为$L_1 : u-...-v_11-v_1-v$, 在$T_my$ 得到的瓶颈路径为$L_2 : u-...-v_01_-v_0-v$。显然$v_0$在$v$之前加入$T_my$（否则$v_0$加入时不可能同时加入两条边$(v_0,v),(v_01,v_0)$），并且两条路径可以连成一个环$C$。再根据$v_1$ 和$v$ 加入$T_my$的顺序讨论：\\ $(a)$如果$v_1$先进$T_my$，则加入$v$时$(v,v_1),(v,v_0)$都是候选线段，按照反证假设，肯定会选$(v,v_1)$，所以$T_my$ 中的瓶颈路径就是$u-...-v_11-v_1-v$，一致 \\ $(b)$如果$v_1$后进$T_my$，则算法在加入$v_1$时，候选线段有$(v_1,v)$ 但是却没选，说明$(v_1,v)$加入时是环上值最小的线段，显然环$C$上所以其他边的值都不比$(v_1,v)$小，也就是$L_2$ 的每条边权重都不比$(v_1,v)$小，也就是$L_2$的阈值肯定不必$L_1$小，矛盾！
%  所以当最优链路长度为$k+1$时成立
%  (3)综合上面得证
%
%\section{题目3 最优旅游线路}
%  \paragraph{求最优旅游线路}
%  对dijkstra算法进行修改后求解。设出发点为$u$，目的地为$v$。集合$A$表示已经计算过的从$u$出发所需时间的城市列表，$U-A$表示剩余没有找到的城市列表。初始时$A=\{u\}$。每次循环向$A$中加入一个新点，且新点的旅游时间最短。新点$u_k$的旅游时间的计算方式为：$$cost(u_k)=\min_{a_i\in A and (a_i,u_k)}(cost(a_i)+f_e(cost(a_i))$$其中$(a_i,u_k)$表示$a_i$和$u_k$连边。
%  \paragraph{证明正确性}
%  对于算法生成的所有点，按照离$u$点的间隔点数用数学归纳法证明。\\
%  (1)当距离$u$点距离为0时显然成立，就为点$u$
%  (2)设当间隔点数小于等于k时成立，当间隔点为$k+1$时。反证，假设不成立，设不成立的路径为$L_1 : u-u1-...-u_k-u_{k+1}$，则显然$L_1$的从$u$开始的所有子路径都是最优的，由假设知其都是算法生成的生成数上的点。则当算法加入$u_{k+1}$点进入集合$A$时没有选择$(u_k,u_{k+1})$，说明存在一条路径$L_2 : u-v1-...-v_t-u_{k+1}$代价更小（$L_1$也在候选路径里），则$L_1$不是最优路径，矛盾。
%
%
%\section{题目4 status\_check}
%  \paragraph{$(a)$求最小$status_check$集合}
%  将所有进程按结束时间从早到晚排序，然后依次扫描日志：找到第一个没有被$status_check$集合元素覆盖的进程$th_i$，取其结束时间$end_i$作为新的日志检测点插入$status_check$集合，并将$th_i$之后所有$end_i$日志检测点可以检测到的进程删去（因为已经被$end_i$覆盖了），继续下去直到所有进程都被覆盖，则最终生成的$status_check$集合就是最小$status_check$集合
%
%  \paragraph{证明上述算法的正确性}
%  我们证明：对于任意一个最优解，都可以转化成按照上述算法得到的解，不改变集合的元素个数。由算法求解结果的唯一性说明算法求解的结果就是一个最优解。\\
%  设$(a)$得到的集合为$S={s_1,...,s_m}$,设一个最优解为$S_0={s_{01},..,s_{0n}}$。不放设$S_0$和$S$的前k个数相同(前k个$status_check$时间点相同)。则对于第$k+1$个时间点$s_{k+1},s_{0(k+1)}$，并且有$s_{k+1}$是按照算法的进程$th_kj$的结束时间。因为$S_0$前k个检测时间没有覆盖$th_kj$，说明$S_0$ 中也应该有一个时间点覆盖了$th_kj$，不妨设为$s_{0(j+1)}$，又$s_{k+1}$是按照算法的进程$th_kj$的结束时间，所以$s_{k+1} > s_{0(j+1)}$，且除了前k个时间点覆盖的集合，$s_{k+1}$覆盖了所有$s_{0(j+1)}$覆盖的集合。将$S_0$中的$s_{0(j+1)}$替换为$s_{k+1}$，记新的集合为$S_0'$。则$S_0'$等同于$S_0$的覆盖性，且$S_0'$ 的元素个数也为n，但是$S_0'$与$S$的相同元素个数变为$k+1$。重复上述过程可以将$S_0$转化为$S$，说明$m=n$，即算法得到的覆盖集合是最小的。\\
%  \paragraph{$(b)$正确}
%  设$(a)$得到的集合为$S={s_1,...,s_m}$，由选取方式可知，这m个检测时间点分别对应一个进程的结束时间，且这m个进程互不重叠，所以最大的互补重叠的进程个数一定大于等于m。而这m个时间点可以覆盖所有的进程，说明任意$m+1$个进程都可以被这m个时间点覆盖，说明至少有一个时间点覆盖了2个进程，即这两个进程相互重叠，所以最大的互补重叠的进程个数一定小于(m+1)。综上，最大的互补重叠的进程个数一定等于最小$status_check$集合的元素个数


\section{题目5 贪心法反例}
  \paragraph{$(a)$不能}
  

\end{document}
